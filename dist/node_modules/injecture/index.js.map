{"version":3,"sources":["../../../src/node_modules/injecture/index.js"],"names":["Emitter","require","EventEmitter2","injectore_store","register_defaults","attributes","silent","singleton","map_instances","instance_index_field","factory_args","factory_context","Injecture","constructor","emitter","wildcard","field","create","key","factory","options","instances","undefined","args","Array","prototype","slice","call","arguments","length","instance","apply","index","Object","keys","registerClass","Klass","register","classFactor","assign","Error","silient","emit","allInstances","map","allInstancesByType","type","injectureSingleton","module","exports"],"mappings":"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","sourcesContent":["const Emitter = require('eventemitter2').EventEmitter2\nconst injectore_store = require('./injecture-store')\n\nconst register_defaults = { \n  attributes: {}, \n  silent: false, \n  singleton: false, \n  map_instances: false,\n  instance_index_field: null,\n  factory_args: [], \n  factory_context: {}\n};\n\nclass Injecture {\n\n  constructor() {\n    const emitter = new Emitter({wildcard:true})\n    for (var field in emitter) {\n      this[field] = emitter[field];\n    }\n  }\n\n  create(key, ...factory_args) {\n    const {\n      factory, options, instances\n    } = injectore_store[key];\n\n    if (!factory) return undefined;\n\n    const args = Array.prototype.slice.call(arguments).length > 1 ? factory_args : options.factory_args;\n    const instance = factory.apply(options.factory_context, args);\n    if (options.map_instances) {\n      // by default they key will just be an auto incrementing umber\n      let index = Object.keys(instances).length;\n      if (options.instance_index_field) {\n        index = instance[options.instance_index_field];\n      }\n      instances[index] = instance;\n    }\n    return instance;\n  }\n\n  /**\n   * This will wrap register \n   * by providing a default Class factory\n   * \n   * @param {*} key \n   * @param {*} options \n   */\n  registerClass(key, Klass, options = { attributes: {}}) {\n    \n    this.register(key, function classFactor() {\n      return new Klass();\n    }, options);\n  }\n\n  register(key, factory, options) {\n    options = Object.assign({}, register_defaults, options);\n    if (injectore_store[key]) throw new Error(`The factory ${key} is already registered`);\n    injectore_store[key] = {\n      factory,\n      options,\n      instances: {}\n    }\n    if (!options.silient) {\n      this.emit(`register.${key}`, key, factory, options);\n    }\n\n  }\n\n  allInstances(key) {\n    if (!injectore_store[key]) return [];\n\n    return Object.keys(injectore_store[key].instances).map(index => {\n      return injectore_store[key].instances[index];\n    });\n\n  }\n\n  allInstancesByType(type) {\n\n  }\n\n}\n\nconst injectureSingleton = new Injecture();\n\nmodule.exports = injectureSingleton;"],"file":"index.js"}