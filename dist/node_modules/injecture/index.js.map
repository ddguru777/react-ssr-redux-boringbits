{"version":3,"sources":["../../../src/node_modules/injecture/index.js"],"names":["Emitter","require","EventEmitter2","injectoreStore","registerDefaults","attributes","silent","singleton","mapInstances","instanceIndexField","factoryArgs","factoryContext","Injecture","constructor","emitter","wildcard","field","create","key","factory","options","instances","undefined","args","Array","prototype","slice","call","arguments","length","instance","apply","index","Object","keys","registerClass","Klass","register","classFactor","assign","Error","silient","emit","allInstances","map","allInstancesByType","type","injectureSingleton","module","exports"],"mappings":"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","sourcesContent":["const Emitter = require('eventemitter2').EventEmitter2;\nconst injectoreStore = require('./injecture-store');\n\nconst registerDefaults = {\n  attributes: {},\n  silent: false,\n  singleton: false,\n  mapInstances: false,\n  instanceIndexField: null,\n  factoryArgs: [],\n  factoryContext: {},\n};\n\nclass Injecture {\n\n  constructor() {\n    const emitter = new Emitter({wildcard: true});\n    // eslint-disable-next-line guard-for-in\n    for (const field in emitter) {\n      this[field] = emitter[field];\n    }\n  }\n\n  create(key, ...factoryArgs) {\n    const {\n      factory, options, instances,\n    } = injectoreStore[key];\n\n    if (!factory) return undefined;\n\n    // eslint-disable-next-line prefer-rest-params\n    const args = Array.prototype.slice.call(arguments).length > 1 ?\n      factoryArgs : options.factoryArgs;\n    const instance = factory.apply(options.factoryContext, args);\n    if (options.mapInstances) {\n      // by default they key will just be an auto incrementing umber\n      let index = Object.keys(instances).length;\n      if (options.instanceIndexField) {\n        index = instance[options.instanceIndexField];\n      }\n      instances[index] = instance;\n    }\n    return instance;\n  }\n\n  /**\n   * This will wrap register\n   * by providing a default Class factory\n   *\n   * @param {*} key\n   * @param {*} Klass\n   * @param {*} options\n   */\n  registerClass(key, Klass, options = {attributes: {}}) {\n\n    this.register(key, function classFactor() {\n      return new Klass();\n    }, options);\n  }\n\n  register(key, factory, options) {\n    options = Object.assign({}, registerDefaults, options);\n    if (injectoreStore[key]) {\n      throw new Error(`The factory ${key} is already registered`);\n    }\n    injectoreStore[key] = {\n      factory,\n      options,\n      instances: {},\n    };\n    if (!options.silient) {\n      this.emit(`register.${key}`, key, factory, options);\n    }\n\n  }\n\n  allInstances(key) {\n    if (!injectoreStore[key]) return [];\n\n    return Object.keys(injectoreStore[key].instances).map(index => {\n      return injectoreStore[key].instances[index];\n    });\n\n  }\n\n  allInstancesByType(type) {\n\n  }\n\n}\n\nconst injectureSingleton = new Injecture();\n\nmodule.exports = injectureSingleton;\n"],"file":"index.js"}