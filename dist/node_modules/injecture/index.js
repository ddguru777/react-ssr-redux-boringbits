const Emitter = require('eventemitter2').EventEmitter2;

const injectoreStore = require('./injecture-store');

const registerDefaults = {
  attributes: {},
  silent: false,
  singleton: false,
  mapInstances: false,
  instanceIndexField: null,
  factoryArgs: [],
  factoryContext: {}
};

class Injecture {
  constructor() {
    const emitter = new Emitter({
      wildcard: true
    }); // eslint-disable-next-line guard-for-in

    for (const field in emitter) {
      this[field] = emitter[field];
    }
  }

  create(key, ...factoryArgs) {
    const {
      factory,
      options,
      instances
    } = injectoreStore[key];
    if (!factory) return undefined; // eslint-disable-next-line prefer-rest-params

    const args = Array.prototype.slice.call(arguments).length > 1 ? factoryArgs : options.factoryArgs;
    const instance = factory.apply(options.factoryContext, args);

    if (options.mapInstances) {
      // by default they key will just be an auto incrementing umber
      let index = Object.keys(instances).length;

      if (options.instanceIndexField) {
        index = instance[options.instanceIndexField];
      }

      instances[index] = instance;
    }

    return instance;
  }
  /**
   * This will wrap register
   * by providing a default Class factory
   *
   * @param {*} key
   * @param {*} Klass
   * @param {*} options
   */


  registerClass(key, Klass, options = {
    attributes: {}
  }) {
    this.register(key, function classFactor() {
      return new Klass();
    }, options);
  }

  register(key, factory, options) {
    options = Object.assign({}, registerDefaults, options);

    if (injectoreStore[key]) {
      throw new Error(`The factory ${key} is already registered`);
    }

    injectoreStore[key] = {
      factory,
      options,
      instances: {}
    };

    if (!options.silient) {
      this.emit(`register.${key}`, key, factory, options);
    }
  }

  allInstances(key) {
    if (!injectoreStore[key]) return [];
    return Object.keys(injectoreStore[key].instances).map(index => {
      return injectoreStore[key].instances[index];
    });
  }

  allInstancesByType(type) {}

}

const injectureSingleton = new Injecture();
module.exports = injectureSingleton;
//# sourceMappingURL=index.js.map