var assert = require('assert');

describe('Boring config', function () {
  it('should export config', function () {
    const boring = require('../../../boring');

    assert.ok(boring);
    assert.ok(boring.config);
    assert.ok(boring.config.get);
    assert.ok(boring.config.has);
  });
  it('should get key in config', () => {
    const config = require('../../../boring').config;

    assert.equal(config.get('app.port'), 4000);
    assert.equal(config.get('boring.app.port'), 4000, 'Since we are setting all keys under boring it will should show up under boring as well');
  });
  it('should get key from .env', () => {
    const config = require('../../../boring').config;

    assert.equal(config.get('boring.foo.bar'), 'beep', 'Value should be overriden from .env');
    assert.equal(config.get('boring.foo.baz'), 'meep', 'Value should come from testing.js, but merged from .env');
    assert.deepEqual(config.get('boring.foo'), {
      bar: 'overriden',
      baz: 'meep'
    }, 'just showing one current deificency');
  });
  /**
   * This is one key enhancment from the `config` API. 
   * config throws if there is no key present, which 
   * we understand the principle / reasoning behind this
   * but would rather have the app deal with an 
   * undefined (or falsy value) rather than catching
   */

  it('should not blow up if key is not present', () => {
    const config = require('../../../boring').config;

    assert.equal(config.get('23423f23f'), undefined);
  });
});
//# sourceMappingURL=config-test.js.map