const UnderstudyBase = require('understudy');

function Understudy() {
  UnderstudyBase.call(this);

  const self = this;
  const perform = this.perform;
  this.perform = function promiseifyPeform(...args) {

    return new Promise((resolve, reject) => {

      const work = args.pop();
      args.push(function workWrapper(next) {

        try {
          let workPromise = work();
          if (!(workPromise instanceof Promise)) {
            // wrap return value in promise
            workPromise = new Promise(workResolve => workResolve(workPromise));
          }

          workPromise.then(function(...workArgs) {
            workArgs.unshift(null);
            next(...workArgs);
          }).catch(next);
        } catch (e) {
          next(e);
        }

      });

      args.push(function finalCallback(...finalArgs) {
        const err = (finalArgs.length) ? finalArgs.shift() : undefined;

        if (err) {
          return reject(err);
        }

        resolve(finalArgs[0]);
      });

      perform.apply(self, args);
    });
  };

  this.performSync = function performSync(...args) {

    const action = args.shift();
    const work = args.pop();
    let retVal;

    function workWrapper(...wrokArgs) {
      const workCb = wrokArgs.pop();
      retVal = work(...wrokArgs);
      workCb(null, retVal);
    }
    function cb() {
      // done noop
    }

    perform.apply(self, [action, ...args, workWrapper, cb]);
    return retVal;
  };

  const before = this.before;
  this.before = function promisifyBefore(...args) {
    const wrappedFn = args.pop();
    args.push(function proxyFn(...proxyArgs) {
      const next = proxyArgs.pop();
      try {
        let promise = wrappedFn.apply(self, proxyArgs);
        if (!(promise instanceof Promise)) promise = Promise.resolve(promise);
        promise.then(next).catch(e => {
          if (!e) e = 'err';
          next(e);
        });
      } catch (e) {
        next(e);
      }
    });

    before.apply(self, args);
  };

  this.beforeSync = function beforeSync(...args) {
    const work = args.pop();
    function workWrapper(...cbArgs) {
      const cb = cbArgs.pop();
      work(...cbArgs);
      cb();
    }
    args.push(workWrapper);
    before.apply(self, args);
  };

  const after = this.after;
  this.after = function promisifyafter(...args) {
    const wrappedFn = args.pop();
    args.push(function proxyFn(...proxyArgs) {
      const next = proxyArgs.pop();
      let promise = wrappedFn.apply(self, proxyArgs);
      if (!(promise instanceof Promise)) promise = new Promise(resolve => resolve(promise));
      promise.then(next).catch(e => {
        if (!e) e = 'err';
        next(e);
      });
    });

    after.apply(self, args);
  };

}

module.exports = Understudy;
