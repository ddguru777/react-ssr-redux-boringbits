
const cls = require('boring-cls');
const assert = require('assert');

function getVal() {
  const writer = cls.getNamespace('writer');
  return writer.get('value');
}

function randoAyncCall(str, cb) {

  return new Promise(resolve => {

    setTimeout(() => {
      const writer = cls.getNamespace('writer');
      str += writer.get('value');
      resolve(str);
    }, Math.round(Math.random() * 10));

  });
}


function requestHandler(str) {

  const writer = cls.getNamespace('writer');
  str += writer.get('value');

  return new Promise(resolve => {

    writer.run(function(outer) {
      // writer.get('value') returns 0
      str += writer.get('value');
      // outer.value is 0
      writer.set('value', 1);
      // writer.get('value') returns 1
      str += writer.get('value');
      // outer.value is 1
      process.nextTick(function() {
        // writer.get('value') returns 1
        str += writer.get('value');
        // outer.value is 1
        setTimeout(() => {
          writer.run(function(inner) {
            // writer.get('value') returns 1
            str += writer.get('value');
            // outer.value is 1
            // inner.value is 1
            writer.set('value', 2);
            // writer.get('value') returns 2
            str += writer.get('value');
            str += getVal();
            // outer.value is 1
            // inner.value is 2

            resolve(str);
          });
        }, Math.round(Math.random() * 10));
      });
    });
  });
}

function make(writer) {

  return new Promise((resolve, reject) => {
    setTimeout(() => {

      writer.run(function() {
        writer.set('value', 0);

        const str = writer.get('value') + ':';
        randoAyncCall(str).then(str => {
          str += writer.get('value');

          requestHandler(str + '-').then(str => {
            setTimeout(function() {
              // runs with the default context, because nested contexts have ended
              str += ':'+writer.get('value');
              resolve(str);
            }, Math.round(Math.random() * 10));
          });

        });

      });
    });
  }, Math.round(Math.random() * 100)); // make each request "random" within 100 ms of each other
}

describe.only('boring-cls', function() {

  // eslint-disable-next-line no-invalid-this
  this.timeout(10000);

  it('simple cls test', function(done) {
    const writer = cls.createNamespace('writer');
    writer.run(function() {
      writer.set('value', 'A');
      assert.equal(writer.get('value'), 'A');
      assert.equal(getVal(), 'A');

      setTimeout(() => {
        assert.equal(getVal(), 'A', 'can survive a timeout');

        (new Promise(resolve => {
          setTimeout(() => resolve(getVal()), 10);
        })).then(val => {
          assert.equal(val, 'A', 'Can survive a promise');
          done();
        });

      }, 3);
    });
  });

  /**
   * There is no reason to suspect this shouldn't work,
   * more or less this code is simple proof CLS can be
   * relied upon.  This test simulates 1000 requests
   * all needing isolated contexts from CLS.
   */
  it('Ensure CLS is deterministic against many randomized requests', function(done) {

    const promises = [];

    const writer = cls.createNamespace('writer');
    for (let i =0; i<1000; i++) promises.push(make(writer));
    Promise.all(promises).then(results => {

      results.forEach(result => {
        assert.equal(result, '0:00-0011122:0');
      });
      done();
    });
  });

});


